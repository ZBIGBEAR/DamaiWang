# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# CDP domain: PWA (experimental)
from __future__ import annotations
from .util import event_class, T_JSON_DICT
from dataclasses import dataclass
import enum
import typing
from . import target


@dataclass
class FileHandlerAccept:
    '''
    The following types are the replica of
    https://crsrc.org/c/chrome/browser/web_applications/proto/web_app_os_integration_state.proto;drc=9910d3be894c8f142c977ba1023f30a656bc13fc;l=67
    '''
    #: New name of the mimetype according to
    #: https://www.iana.org/assignments/media-types/media-types.xhtml
    media_type: str

    file_extensions: typing.List[str]

    def to_json(self):
        json = dict()
        json['mediaType'] = self.media_type
        json['fileExtensions'] = [i for i in self.file_extensions]
        return json

    @classmethod
    def from_json(cls, json):
        return cls(
            media_type=str(json['mediaType']),
            file_extensions=[str(i) for i in json['fileExtensions']],
        )


@dataclass
class FileHandler:
    action: str

    accepts: typing.List[FileHandlerAccept]

    display_name: str

    def to_json(self):
        json = dict()
        json['action'] = self.action
        json['accepts'] = [i.to_json() for i in self.accepts]
        json['displayName'] = self.display_name
        return json

    @classmethod
    def from_json(cls, json):
        return cls(
            action=str(json['action']),
            accepts=[FileHandlerAccept.from_json(i) for i in json['accepts']],
            display_name=str(json['displayName']),
        )


def get_os_app_state(
        manifest_id: str
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.Tuple[int, typing.List[FileHandler]]]:
    '''
    Returns the following OS state for the given manifest id.

    :param manifest_id: The id from the webapp's manifest file, commonly it's the url of the site installing the webapp. See https://web.dev/learn/pwa/web-app-manifest.
    :returns: A tuple with the following items:

        0. **badgeCount** - 
        1. **fileHandlers** - 
    '''
    params: T_JSON_DICT = dict()
    params['manifestId'] = manifest_id
    cmd_dict: T_JSON_DICT = {
        'method': 'PWA.getOsAppState',
        'params': params,
    }
    json = yield cmd_dict
    return (
        int(json['badgeCount']),
        [FileHandler.from_json(i) for i in json['fileHandlers']]
    )


def install(
        manifest_id: str,
        install_url_or_bundle_url: typing.Optional[str] = None
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Installs the given manifest identity, optionally using the given install_url
    or IWA bundle location.

    TODO(crbug.com/337872319) Support IWA to meet the following specific
    requirement.
    IWA-specific install description: If the manifest_id is isolated-app://,
    install_url_or_bundle_url is required, and can be either an http(s) URL or
    file:// URL pointing to a signed web bundle (.swbn). The .swbn file's
    signing key must correspond to manifest_id. If Chrome is not in IWA dev
    mode, the installation will fail, regardless of the state of the allowlist.

    :param manifest_id:
    :param install_url_or_bundle_url: *(Optional)* The location of the app or bundle overriding the one derived from the manifestId.
    '''
    params: T_JSON_DICT = dict()
    params['manifestId'] = manifest_id
    if install_url_or_bundle_url is not None:
        params['installUrlOrBundleUrl'] = install_url_or_bundle_url
    cmd_dict: T_JSON_DICT = {
        'method': 'PWA.install',
        'params': params,
    }
    json = yield cmd_dict


def uninstall(
        manifest_id: str
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Uninstals the given manifest_id and closes any opened app windows.

    :param manifest_id:
    '''
    params: T_JSON_DICT = dict()
    params['manifestId'] = manifest_id
    cmd_dict: T_JSON_DICT = {
        'method': 'PWA.uninstall',
        'params': params,
    }
    json = yield cmd_dict


def launch(
        manifest_id: str,
        url: typing.Optional[str] = None
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,target.TargetID]:
    '''
    Launches the installed web app, or an url in the same web app instead of the
    default start url if it is provided. Returns a tab / web contents based
    Target.TargetID which can be used to attach to via Target.attachToTarget or
    similar APIs.

    :param manifest_id:
    :param url: *(Optional)*
    :returns: ID of the tab target created as a result.
    '''
    params: T_JSON_DICT = dict()
    params['manifestId'] = manifest_id
    if url is not None:
        params['url'] = url
    cmd_dict: T_JSON_DICT = {
        'method': 'PWA.launch',
        'params': params,
    }
    json = yield cmd_dict
    return target.TargetID.from_json(json['targetId'])
